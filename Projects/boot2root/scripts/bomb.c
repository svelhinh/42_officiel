//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker * e12;
    struct _IO_FILE * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    int32_t e22[16];
};

struct _IO_marker {
    struct _IO_marker * e0;
    struct _IO_FILE * e1;
    int32_t e2;
};

// ------------------- Function Prototypes --------------------

void blank_line(void);
void explode_bomb(void);
void fun7(void);
void func4(void);
void initialize_bomb(void);
void phase_1(void);
void phase_2(void);
void phase_3(void);
void phase_4(void);
void phase_5(void);
void phase_6(void);
void phase_defused(void);
void read_line(void);
void read_six_numbers(void);
void secret_phase(void);
int32_t sig_handler(int32_t a1);
void skip(void);
void string_length(void);
void strings_not_equal(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ebx
int32_t g4 = 0; // esi
int32_t g5 = 0x76727369; // 0x804b220
int32_t g6 = 253; // 0x804b26c
char * g7; // 0x804b480
struct _IO_FILE * g8 = NULL; // 0x804b640
int32_t g9 = 0; // 0x804b644
int32_t g10 = 0; // 0x804b648
int32_t g11 = 0; // 0x804b67f
char * g12; // 0x804b680
char * g13; // 0x804b770
struct _IO_FILE * infile = NULL;

// ------------------------ Functions -------------------------

// From module:   /usr0/droh/213/private/L2/src/bomb.c
// Address range: 0x80489b0 - 0x8048b1f
int main(int argc, char ** argv) {
    int32_t v1 = (int32_t)argv; // 0x80489ba_0
    g3 = v1;
    switch (argc) {
        default: {
            // 0x8048a10
            printf("Usage: %s [<input_file>]\n", (char *)*(int32_t *)argv);
            exit(8);
            // UNREACHABLE
        }
        case 1: {
            // 0x80489c2
            *(int32_t *)&infile = g10;  // Lit sur l'entree standard
            // branch -> 0x8048a30
            break;
        }
        case 2: {
            struct _IO_FILE * file = fopen((char *)*(int32_t *)(v1 + 4), "r"); // 0x80489e1
            *(int32_t *)&infile = (int32_t)file;
            if (file == NULL) {
                int32_t v2 = *(int32_t *)(g3 + 4); // 0x80489f5
                int32_t v3 = *(int32_t *)g3; // 0x80489f9
                printf("%s: Error: Couldn't open %s\n", (char *)v3, (char *)v2);
                exit(8);
                // UNREACHABLE
            }
            break;
        }
    }
    // 0x8048a30
    initialize_bomb();
    printf("Welcome this is my little bomb !!!! You have 6 stages with\n");
    printf("only one life good luck !! Have a nice day!\n");
    read_line();
    phase_1();
    phase_defused();
    printf("Phase 1 defused. How about the next one?\n");
    read_line();
    phase_2();
    phase_defused();
    printf("That's number 2.  Keep going!\n");
    read_line();
    phase_3();
    phase_defused();
    printf("Halfway there!\n");
    read_line();
    phase_4();
    phase_defused();
    printf("So you got that one.  Try this one.\n");
    read_line();
    phase_5();
    phase_defused();
    printf("Good work!  On to the next...\n");
    read_line();
    phase_6();
    phase_defused();
    return 0;
}

// Address range: 0x8048b20 - 0x8048b47
void phase_1(void) {
    // 0x8048b20
    strings_not_equal();
    if (g1 != 0) {
        // 0x8048b3e
        explode_bomb();
        // branch -> 0x8048b43
    }
}

// Address range: 0x8048b48 - 0x8048b97
void phase_2(void) {
    int32_t v1;
    int32_t v2 = &v1; // 0x8048b56_0
    read_six_numbers();
    if (v1 != 1) {
        // 0x8048b69
        explode_bomb();
        // branch -> 0x8048b6e
    }
    int32_t v3 = 1; // ebx
    int32_t v4 = v2; // 0x8048b7e
    int32_t v5 = 1; // 0x8048b7e
    // branch -> 0x8048b76
    while (true) {
        int32_t v6 = 4 * v5; // 0x8048b79
        int32_t v7 = *(int32_t *)(v4 - 4 + v6); // 0x8048b79
        int32_t v8 = *(int32_t *)(v6 + v4); // 0x8048b7e
        int32_t v9 = v5; // 0x8048b88
        if (v8 != v7 * (v5 + 1)) {
            // 0x8048b83
            explode_bomb();
            v9 = v3;
            // branch -> 0x8048b88
        }
        int32_t v10 = v9 + 1; // 0x8048b88
        v3 = v10;
        if (v10 >= 6) {
            // 0x8048b8e
            return;
        }
        // 0x8048b88
        v4 = v2;
        v5 = v10;
        // branch -> 0x8048b76
    }
}

// Address range: 0x8048b98 - 0x8048c9f
void phase_3(void) {
    int32_t v1;
    char v2 = v1; // bp-9
    int32_t v3;
    g2 = &v3;
    int32_t v4 = g3; // 0x8048b9e
    int32_t str;
    int32_t v5;
    int32_t v6;
    uint32_t items_assigned = sscanf((char *)str, "%d %c %d", &v5, &v2, &v6);
    if (items_assigned <= 2) {
        // 0x8048bc4
        explode_bomb();
        // branch -> 0x8048bc9
    }
    // 0x8048bc9
    switch (v5) {
        default: {
            // 0x8048c88
            explode_bomb();
            // branch -> 0x8048c8f
            break;
        }
        case 0: {
            // 0x8048be0
            if (*(int32_t *)(g2 - 4) != 777) {
                // 0x8048bef
                explode_bomb();
                // branch -> 0x8048c8f
            }
            // 0x8048c8f
            if ((g3 & -256 || 113) != (int32_t)v2) {
                // 0x8048c94
                explode_bomb();
                // branch -> 0x8048c99
            }
            // 0x8048c99
            g3 = v4;
            return;
        }
        case 1: {
            // 0x8048c00
            if (*(int32_t *)(g2 - 4) != 214) {
                // 0x8048c0f
                explode_bomb();
                // branch -> 0x8048c8f
            }
            // 0x8048c8f
            if ((g3 & -256 || 98) != (int32_t)v2) {
                // 0x8048c94
                explode_bomb();
                // branch -> 0x8048c99
            }
            // 0x8048c99
            g3 = v4;
            return;
        }
        case 2: {
            // 0x8048c16
            if (v6 != 755) {
                // 0x8048c21
                explode_bomb();
                // branch -> 0x8048c8f
            }
            // 0x8048c8f
            if ((g3 & -256 || 98) != (int32_t)v2) {
                // 0x8048c94
                explode_bomb();
                // branch -> 0x8048c99
            }
            // 0x8048c99
            g3 = v4;
            return;
        }
        case 3: {
            // 0x8048c28
            if (v6 != 251) {
                // 0x8048c33
                explode_bomb();
                // branch -> 0x8048c8f
            }
            // 0x8048c8f
            if ((g3 & -256 || 107) != (int32_t)v2) {
                // 0x8048c94
                explode_bomb();
                // branch -> 0x8048c99
            }
            // 0x8048c99
            g3 = v4;
            return;
        }
        case 4: {
            // 0x8048c40
            if (*(int32_t *)(g2 - 4) != 160) {
                // 0x8048c4b
                explode_bomb();
                // branch -> 0x8048c8f
            }
            // 0x8048c8f
            if ((g3 & -256 || 111) != (int32_t)v2) {
                // 0x8048c94
                explode_bomb();
                // branch -> 0x8048c99
            }
            // 0x8048c99
            g3 = v4;
            return;
        }
        case 5: {
            // 0x8048c52
            if (v6 != 458) {
                // 0x8048c5d
                explode_bomb();
                // branch -> 0x8048c8f
            }
            // 0x8048c8f
            if ((g3 & -256 || 116) != (int32_t)v2) {
                // 0x8048c94
                explode_bomb();
                // branch -> 0x8048c99
            }
            // 0x8048c99
            g3 = v4;
            return;
        }
        case 6: {
            // 0x8048c64
            if (v6 != 780) {
                // 0x8048c6f
                explode_bomb();
                // branch -> 0x8048c8f
            }
            // 0x8048c8f
            if ((g3 & -256 || 118) != (int32_t)v2) {
                // 0x8048c94
                explode_bomb();
                // branch -> 0x8048c99
            }
            // 0x8048c99
            g3 = v4;
            return;
        }
        case 7: {
            // 0x8048c76
            if (v6 != 524) {
                // 0x8048c81
                explode_bomb();
                // branch -> 0x8048c8f
            }
            // 0x8048c8f
            if ((g3 & -256 || 98) != (int32_t)v2) {
                // 0x8048c94
                explode_bomb();
                // branch -> 0x8048c99
            }
            // 0x8048c99
            g3 = v4;
            return;
        }
    }
    // 0x8048c8f
    if ((g3 & -256 || 120) != (int32_t)v2) {
        // 0x8048c94
        explode_bomb();
        // branch -> 0x8048c99
    }
    // 0x8048c99
    g3 = v4;
}

// Address range: 0x8048ca0 - 0x8048cdd
void func4(void) {
    int32_t v1 = g4; // 0x8048ca6
    int32_t v2 = g3; // 0x8048ca7
    uint32_t v3;
    g3 = v3;
    int32_t v4;
    if (v3 >= 2) {
        // 0x8048cb0
        func4();
        int32_t v5 = g1; // 0x8048cbc
        g4 = v5;
        func4();
        v4 = g1 + v5;
        // branch -> 0x8048cd5
    } else {
        v4 = 1;
    }
    // 0x8048cd5
    g1 = v4;
    g3 = v2;
    g4 = v1;
}

// Address range: 0x8048ce0 - 0x8048d2b
void phase_4(void) {
    int32_t str;
    int32_t v1;
    if (sscanf((char *)str, "%d", &v1) != 1 || v1 <= 0) {
        // 0x8048d09
        explode_bomb();
        // branch -> 0x8048d0e
    }
    // 0x8048d0e
    func4();
    if (g1 != 55) {
        // 0x8048d22
        explode_bomb();
        // branch -> 0x8048d27
    }
}

// Address range: 0x8048d2c - 0x8048d94
void phase_5(void) {
    int32_t v1 = g4; // 0x8048d32
    int32_t v2 = g3; // 0x8048d33
    int32_t v3;
    g3 = v3;
    string_length();
    if (g1 != 6) {
        // 0x8048d48
        explode_bomb();
        // branch -> 0x8048d4d
    }
    int32_t v4 = 0; // edx
    g4 = &g5;
    int32_t v5 = &g5; // 0x8048d5f
    int32_t v6 = 0; // 0x8048d62
    // branch -> 0x8048d57
    while (true) {
        unsigned char v7 = *(char *)(g3 + v6); // 0x8048d57
        char v8 = *(char *)((int32_t)(v7 % 16) + v5); // 0x8048d5f
        int32_t v9;
        *(char *)(v6 + (int32_t)&v9) = v8;
        int32_t v10 = v4 + 1; // 0x8048d65
        v4 = v10;
        if (v10 >= 6) {
            // 0x8048d6b
            strings_not_equal();
            if (g1 != 0) {
                // 0x8048d87
                explode_bomb();
                // branch -> 0x8048d8c
            }
            // 0x8048d8c
            g3 = v2;
            g4 = v1;
            return;
        }
        // 0x8048d57
        v5 = g4;
        v6 = v10;
        // branch -> 0x8048d57
    }
}

// Address range: 0x8048d98 - 0x8048e90
void phase_6(void) {
    int32_t v1;
    int32_t v2 = &v1; // 0x8048dae_0
    read_six_numbers();
    int32_t v3 = 0; // edi
    int32_t v4 = 0; // 0x8048dc3
    // branch -> 0x8048dc0
    while (true) {
        int32_t v5 = v4; // 0x8048dd9
        if (*(int32_t *)(4 * v4 + v2) >= 7) {
            // 0x8048dcc
            explode_bomb();
            v5 = v3;
            // branch -> 0x8048dd1
        }
        int32_t v6 = v5 + 1; // 0x8048dd1
        int32_t v7 = v6; // ebx
        if (v6 <= 5) {
            int32_t v8 = v2; // 0x8048de9
            // branch -> 0x8048de6
            while (true) {
                int32_t v9 = *(int32_t *)(v8 + 4 * v5); // 0x8048de9
                int32_t v10 = v6; // 0x8048df6
                if (v9 == *(int32_t *)(4 * v6 + v8)) {
                    // 0x8048df1
                    explode_bomb();
                    v10 = v7;
                    // branch -> 0x8048df6
                }
                int32_t v11 = v10 + 1; // 0x8048df6
                v7 = v11;
                if (v11 < 6) {
                    // 0x8048df6
                    v6 = v11;
                    v8 = v2;
                    // branch -> 0x8048de6
                    continue;
                }
            }
        }
        int32_t v12 = v3 + 1; // 0x8048dfc
        v3 = v12;
        if (v12 >= 6) {
            // break -> 0x8048e02
            break;
        }
        v4 = v12;
        // continue -> 0x8048dc0
    }
    // 0x8048e02
    v3 = 0;
    int32_t v13;
    int32_t v14 = &v13; // 0x8048e07_0
    int32_t v15 = 0; // 0x8048e3b
    // branch -> 0x8048e10
    while (true) {
        uint32_t v16 = *(int32_t *)(4 * v15 + v2); // 0x8048e21
        int32_t v17 = &g6; // 0x8048e3b
        int32_t v18; // 0x8048e3e
        int32_t v19; // 0x8048e5a
        int32_t v20; // 0x8048e5a46
        int32_t v21; // esi
        int32_t v22; // 0x8048e58
        int32_t v23; // 0x8048e5844
        int32_t v24; // 0x8048e81
        int32_t v25; // 0x8048e70
        int32_t v26; // 0x8048e7e
        int32_t v27; // 0x8048e44
        int32_t v28; // 0x8048e52
        int32_t v29; // 0x8048e5241
        if (v16 > 1) {
            int32_t v30 = 1; // 0x8048e33
            int32_t v31 = *(int32_t *)((int32_t)&g6 + 8); // 0x8048e30
            // branch -> 0x8048e30
            while (v30 + 1 < v16) {
                // 0x8048e30
                v30++;
                v31 += 8;
                // continue -> 0x8048e30
            }
            // 0x8048e38
            *(int32_t *)(4 * v15 + v14) = v31;
            v18 = v3 + 1;
            v3 = v18;
            if (v18 < 6) {
              lab_0x8048e38:
                // 0x8048e38
                v15 = v18;
                // branch -> 0x8048e10
                continue;
            } else {
                // 0x8048e44
                v27 = v13;
                v29 = *(int32_t *)(v14 + 4);
                *(int32_t *)(v27 + 8) = v29;
                v23 = v29;
                v20 = 2;
                if (v20 < 6) {
                    v28 = *(int32_t *)(4 * v20 + v14);
                    *(int32_t *)(v23 + 8) = v28;
                    v22 = v28;
                    v19 = v20 + 1;
                    while (v19 < 6) {
                        // 0x8048e52
                        v28 = *(int32_t *)(4 * v19 + v14);
                        *(int32_t *)(v22 + 8) = v28;
                        v22 = v28;
                        v19++;
                        // continue -> 0x8048e52
                    }
                    // 0x8048e60
                    *(int32_t *)(v22 + 8) = 0;
                    v21 = v27;
                    v3 = 0;
                    int32_t v32 = 0; // 0x8048e8137
                    v25 = v27;
                    // branch -> 0x8048e70
                    while (true) {
                        // 0x8048e70
                        v24 = v32;
                        v26 = v25;
                        if (*(int32_t *)v25 < *(int32_t *)*(int32_t *)(v25 + 8)) {
                          lab_0x8048e79_3:
                            // 0x8048e79
                            explode_bomb();
                            v24 = v3;
                            v26 = v21;
                            // branch -> 0x8048e7e
                        }
                      lab_0x8048e7e_3:;
                        int32_t v33 = *(int32_t *)(v26 + 8); // 0x8048e7e
                        v21 = v33;
                        int32_t v34 = v24 + 1; // 0x8048e81
                        v3 = v34;
                        if (v34 >= 5) {
                            // break -> 0x8048e87
                            break;
                        }
                        v32 = v34;
                        v25 = v33;
                        // continue -> 0x8048e70
                    }
                    // 0x8048e87
                    return;
                }
                // 0x8048e60
                *(int32_t *)(v23 + 8) = 0;
                v21 = v27;
                v3 = 0;
                v25 = v27;
                // branch -> 0x8048e70
                while (true) {
                    // 0x8048e70
                    if (*(int32_t *)v25 < *(int32_t *)*(int32_t *)(v25 + 8)) {
                        goto lab_0x8048e79_3;
                    }
                    v24 = 0;
                    v26 = v25;
                    goto lab_0x8048e7e_3;
                }
            }
        }
        // 0x8048e38
        *(int32_t *)(4 * v15 + v14) = v17;
        v18 = v3 + 1;
        v3 = v18;
        if (v18 < 6) {
            goto lab_0x8048e38;
        }
        // 0x8048e44
        v27 = v13;
        v29 = *(int32_t *)(v14 + 4);
        *(int32_t *)(v27 + 8) = v29;
        v23 = v29;
        v20 = 2;
        if (v20 < 6) {
            v28 = *(int32_t *)(4 * v20 + v14);
            *(int32_t *)(v23 + 8) = v28;
            v22 = v28;
            v19 = v20 + 1;
            while (v19 < 6) {
                // 0x8048e52
                v28 = *(int32_t *)(4 * v19 + v14);
                *(int32_t *)(v22 + 8) = v28;
                v22 = v28;
                v19++;
                // continue -> 0x8048e52
            }
            // 0x8048e60
            *(int32_t *)(v22 + 8) = 0;
            v21 = v27;
            v3 = 0;
            v25 = v27;
            // branch -> 0x8048e70
            while (true) {
                // 0x8048e70
                if (*(int32_t *)v25 < *(int32_t *)*(int32_t *)(v25 + 8)) {
                    goto lab_0x8048e79_3;
                }
                v24 = 0;
                v26 = v25;
                goto lab_0x8048e7e_3;
            }
        }
        // 0x8048e60
        *(int32_t *)(v23 + 8) = 0;
        v21 = v27;
        v3 = 0;
        v25 = v27;
        // branch -> 0x8048e70
        while (true) {
            // 0x8048e70
            if (*(int32_t *)v25 < *(int32_t *)*(int32_t *)(v25 + 8)) {
                goto lab_0x8048e79_3;
            }
            v24 = 0;
            v26 = v25;
            goto lab_0x8048e7e_3;
        }
    }
}

// Address range: 0x8048e94 - 0x8048ee5
void fun7(void) {
    // 0x8048e94
    int32_t v1;
    if (v1 == 0) {
        // 0x8048ea4
        g1 = -1;
        // branch -> 0x8048ee2
        // 0x8048ee2
        return;
    }
    int32_t v2 = *(int32_t *)v1; // 0x8048eb0
    int32_t v3;
    if (v3 < v2) {
        // 0x8048eb4
        fun7();
        g1 *= 2;
        // branch -> 0x8048ee2
        // 0x8048ee2
        return;
    }
    // 0x8048ec5
    if (v3 == v2) {
        // 0x8048ee0
        g1 = 0;
        // branch -> 0x8048ee2
    } else {
        // 0x8048ec9
        fun7();
        g1 = 2 * g1 | 1;
        // branch -> 0x8048ee2
    }
}

// Address range: 0x8048ee8 - 0x8048f4f
void secret_phase(void) {
    // 0x8048ee8
    read_line();
    int32_t v1 = __strtol_internal((char *)g1, NULL, 10, 0); // 0x8048efb
    g3 = v1;
    if (v1 >= 1002) {
        // 0x8048f0f
        explode_bomb();
        // branch -> 0x8048f14
    }
    // 0x8048f14
    fun7();
    if (g1 != 7) {
        // 0x8048f2a
        explode_bomb();
        // branch -> 0x8048f2f
    }
    // 0x8048f2f
    printf("Wow! You've defused the secret stage!\n");
    phase_defused();
}

// Address range: 0x8048f50 - 0x8048fb1
int32_t sig_handler(int32_t a1) {
    // 0x8048f50
    printf("So you think you can stop the bomb with ctrl-c, do you?\n");
    sleep(3);
    printf("Well...");
    fflush(g8);
    sleep(1);
    printf("OK. :-)\n");
    exit(16);
    // UNREACHABLE
}

// Address range: 0x8048fd8 - 0x8049014
void read_six_numbers(void) {
    // 0x8048fd8
    int32_t str;
    int32_t v1;
    if (sscanf((char *)str, "%d %d %d %d %d %d", (int32_t *)v1, (int32_t *)(v1 + 4), (int32_t *)(v1 + 8), (int32_t *)(v1 + 12), (int32_t *)(v1 + 16), (int32_t *)(v1 + 20)) <= 5) {
        // 0x804900c
        explode_bomb();
        // branch -> 0x8049011
    }
}

// Address range: 0x8049018 - 0x804902f
void string_length(void) {
    // 0x8049018
    g1 = 0;
    int32_t v1;
    if (*(char *)v1 == 0) {
        // 0x804902c
        return;
    }
    int32_t v2 = v1 + 1; // 0x8049025
    int32_t v3 = 1; // 0x8049026
    g1 = v3;
    while (*(char *)v2 != 0) {
        // 0x8049025
        v2++;
        v3++;
        g1 = v3;
        // continue -> 0x8049025
    }
}

// Address range: 0x8049030 - 0x8049088
void strings_not_equal(void) {
    string_length();
    int32_t v1 = g1; // 0x8049048
    string_length();
    if (v1 != g1) {
        // 0x804907f
        g1 = 1;
        return;
    }
    // 0x8049060
    int32_t v2;
    char v3 = *(char *)v2; // 0x8049064
    if (v3 == 0) {
        // 0x804907f
        g1 = 0;
        return;
    }
    int32_t v4;
    while (true) {
        int32_t v5 = (int32_t)v3 | v1 & -256; // 0x8049070
        int32_t v6;
        if (v5 == (int32_t)*(char *)v6) {
            int32_t v7 = v2 + 1; // 0x8049076
            char v8 = *(char *)v7; // 0x8049078
            if (v8 == 0) {
                v4 = 0;
                // break -> 0x804907f
                break;
            }
            v6++;
            v1 = v5;
            v3 = v8;
            v2 = v7;
            // continue -> 0x8049070
            continue;
        } else {
            v4 = 1;
        }
    }
    // 0x804907f
    g1 = v4;
}

// Address range: 0x8049160 - 0x8049178
void initialize_bomb(void) {
    // 0x8049160
    signal(SIGINT, (void (**)(int32_t))sig_handler);    // C'est pour catch les touches clavier
}

// Address range: 0x804917c - 0x80491ad
void blank_line(void) {
    // 0x804917c
    int32_t v1;
    char * v2 = (char *)v1;
    if (*v2 == 0) {
        // 0x80491aa
        return;
    }
    char v3 = *v2; // 0x8049190
    // branch -> 0x8049190
    while (true) {
        int32_t v4 = v1 + 1; // 0x8049193
        if (*(char *)(g9 + 1 + 2 * (int32_t)v3) == 32) {
            // 0x80491aa
            return;
        }
        char v5 = *(char *)v4; // 0x80491a0
        if (v5 == 0) {
            // break -> 0x80491aa
            break;
        }
        v3 = v5;
        v1 = v4;
        // continue -> 0x8049190
    }
}

// Address range: 0x80491b0 - 0x80491f9
void skip(void) {
    // 0x80491b0
    int32_t stream = *(int32_t *)&infile; // 0x80491ba  // fd qu'on a recupere
    char * str = fgets((char *)(80 * (int32_t)g7 + (int32_t)&g12), 80, (struct _IO_FILE *)stream); // 0x80491d3 // Lit 80 octets du fichier
    // 0x80491f1
    g1 = (int32_t)str;
    // branch -> 0x80491b7
    while (str != NULL) {
        // 0x80491b7
        // 0x80491e1
        blank_line();
        stream = *(int32_t *)&infile;
        str = fgets((char *)(80 * (int32_t)g7 + (int32_t)&g12), 80, (struct _IO_FILE *)stream);
        // 0x80491f1
        g1 = (int32_t)str;
        // branch -> 0x80491b7
    }
}

// Address range: 0x80491fc - 0x80492bc
void read_line(void) {
    // 0x80491fc
    skip();
    int32_t len;
    int32_t v1; // 0x80492a0
    if (g1 == 0) {
        // 0x804920c
        if (*(int32_t *)&infile != g10) {
            char * env_val = getenv("GRADE_BOMB"); // 0x8049221
            g1 = (int32_t)env_val;
            if (env_val != NULL) {
                // 0x804922d
                exit(0);
                // UNREACHABLE
            }
            // 0x8049237
            *(int32_t *)&infile = g10;
            skip();
            if (g1 == 0) {
                // 0x804924a
                printf("Error: Premature EOF on stdin\n");
                explode_bomb();
                // branch -> 0x804925f
            }
            // 0x804925f
            len = strlen((char *)(80 * (int32_t)g7 + (int32_t)&g12));
            if (len == 79) {
                // 0x8049286
                printf("Error: Input line too long\n");
                explode_bomb();
                // branch -> 0x8049298
            }
            // 0x8049298
            v1 = 80 * (int32_t)g7;
            *(char *)(len + (int32_t)&g11 + v1) = 0;
            g1 = v1 + (int32_t)&g12;
            g7 = (char *)((int32_t)g7 + 1);
            return;
        }
        // 0x804924a
        printf("Error: Premature EOF on stdin\n");
        explode_bomb();
        // branch -> 0x804925f
    }
    // 0x804925f
    len = strlen((char *)(80 * (int32_t)g7 + (int32_t)&g12));
    if (len == 79) {
        // 0x8049286
        printf("Error: Input line too long\n");
        explode_bomb();
        // branch -> 0x8049298
    }
    // 0x8049298
    v1 = 80 * (int32_t)g7;
    *(char *)(len + (int32_t)&g11 + v1) = 0;
    g1 = v1 + (int32_t)&g12;
    g7 = (char *)((int32_t)g7 + 1);
}

// Address range: 0x80494fc - 0x8049528
void explode_bomb(void) {
    int32_t v1;
    g2 = &v1;
    printf("\nBOOM!!!\n");
    printf("The bomb has blown up.\n");
    exit(8);
    // UNREACHABLE
}

// Address range: 0x804952c - 0x80495af
void phase_defused(void) {
    int32_t v1 = g3; // 0x8049532
    if (g7 == (char *)6) {
        // 0x804953c
        int32_t v2;
        g3 = &v2;
        int32_t v3;
        if (sscanf((char *)&g13, "%d %s", &v3, &v2) == 2) {
            // 0x804955b
            strings_not_equal();
            // branch -> 0x8049592
        }
        // 0x8049592
        printf("Congratulations! You've defused the bomb!\n");
        // branch -> 0x804959f
    }
    // 0x804959f
    g3 = v1;
}

// --------------- Dynamically Linked Functions ---------------

// long int __strtol_internal(const char * restrict nptr, char ** restrict endptr, int base, int group);
// void exit(int status);
// int fflush(FILE * stream);
// char * fgets(char * restrict s, int n, FILE * restrict stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// char * getenv(const char * name);
// int printf(const char * restrict format, ...);
// __sighandler_t signal(int sig, __sighandler_t handler);
// unsigned int sleep(unsigned int seconds);
// int sscanf(const char * restrict s, const char * restrict format, ...);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (2.95.3)
// Detected language: C
// Detected functions: 20
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2018-04-27 16:02:22
